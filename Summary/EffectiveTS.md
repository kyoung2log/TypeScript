### 1장 타입스크립트 알아보기

> **아이템 1 : 타입스크립트와 자바스크립트의 관계 이해하기**

- 타입스크립트는 자바스크립트의 상위집합이다. 다시말해서, 모든 자바스크립트 프로그램은 이미 타입스크립트 프로그램이다. 반대로 타입스크립트는 별도의 문법을 가지고 있기 때문에 일반적으로는 유효한 자바스크립트 프로그램이 아니다.
- 타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있기 때문에 런타임 오류를 발생시키는 코드를 찾아내려고 한다. 그러나 모든 오류를 찾아내리라 기대하면 안된다. 타입 체커를 통과하면서도 런타임 오류를 발생시키는 코드가 존재할 수 있다.
- 타입스크립트 타입시스템은 전반적으로 자바스크립트 동작을 모델링한다. 그러나 잘못된 매개변수 개수로 함수를 호출하는 경우처럼, 자바스크립트에서는 허용되지만 타입스크립트에서는 문제가 되는 경우도 있다. 이러한 문법의 엄격함은 온전히 취향의 차이이며 우열을 가릴 수 없는문제다.

> **아이템 2 : 타입스크립트 설정 이해하기 (tsconfig.js)**

- 타입스크립트 컴파일러는 언어의 핵심 요소에 영향을 미치는 몇가지 설정을 포함하고 있다.
- 타입스크립트 설정은 커맨드 라인을 이용하기 보다는 tsconfig.json을 사용하는 것이 좋다.
- 자바스크립트 프로젝트를 타입스크립트로 전환하는 게 아니라면 noImplicitAny를 설정하는 것이 좋다.
  - `noImplicitAny` : 타입을 명시하지 않았을 때, 암묵적으로 any 타입으로 추론되는 것을 허용/비허용
- “undefined는 객체가 아닙니다” 같은 런타임 오류를 방지하기 위해 strictNullChecks를 설정하는 것이 좋다.
  - `strictNullChecks` : `null/undefined` 타입을 모든 타입에 허용/비허용
- 타입스크립트에서 엄격한 체크를 하고 싶다면 strict 설정을 고려해야 한다.

> **아이템3 : 코드 생성과 타입이 관계 없음을 이해하기**

- 코드 생성은 타입시스템과 무관하다. 타입스크립트 타입은 런타임 동작이나 성능에 영향을 주지 않는다.
- 타입 오류가 존재하더라도 코드 생성(컴파일)은 가능하다.
- 타입스크립트 타입은 런타임환경에서 지워지므로 런타임에 사용할 수 없다. 런타임에 타입을 지정하려면, 타입 정보 유지를 위한 별도의 방법이 필요하다. 일반적으로는 태그된 유니온과 속성체크방법을 사용한다. 또는 클래스와 같이 타입스크립트 타입과 런타임 값 둘 다 제공하는 방법이 있다.

> **아이템 4 : 구조적 타이핑에 익숙해지기**

- 자바스크립트가 덕 타이핑 기반이고 타입스크립트가 이를 모델링하기 위해 구조적 타이핑을 사용함을 이해해야 한다. 어떤 인터페이스에 할당 가능한 값이라면 타입 선언에 명시적으로 나열된 속성들을 가지고 있을 것이다. 타입은 봉인되어 있지 않다.
  - 왜냐하면 덕 타이핑의 특징을 가지는 JS를 기반으로 작성 + 정적 타입시스템을 채택했기 때문에 구조적 타이핑을 채택해야 했음
- 클래스 역시 구조적 타이핑 규칙을 따른다는 것을 명시해야 한다. 클래스의 인스턴스가 예상과 다를 수 있다.
- 구조적 타이핑을 사용하면 유닛 테스팅을 손쉽게 할 수 있다.

> **아이템 5 : any 타입 지양하기**

- any 타입을 사용하면 타입 체커와 타입 스크립트 언어 서비스를 무력화시킨다. any 타입은 진짜 문제점을 감추며, 개발 경험을 나쁘게 하고, 타입 시스템의 신뢰도를 떨어뜨리니 사용을 최소화 해야한다.

### 2장 타입스크립트의 타입시스템

> **아이템 6 : 편집기를 사용하여 시스템 탐색하기**

- 편집기에서 타입스크립트 언어 서비스를 적극 활용해야 한다.
- 편집기를 사용하면 어떻게 타입 시스템이 동작하는지, 그리고 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있다.
- 타입스크립트가 동작을 어떻게 모델링 하는지 알기 위해 타입 선언 파일을 찾아보는 방법을 알아야 한다.

> **아이템 7 : 타입이 값들의 집합이라고 생각하기**

- 타입을 값의 집합으로 생각하면 이해하기 편하다. 이 집합은 유한하거나, 무한하다.
- 타입스크립트 타입은 엄격한 상속관계가 아니라 겹쳐지는 집합으로 표현된다. 두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있다.
- 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있다.
- 타입 연산은 집합의 범위에 적용된다.
  - keyof (A&B) = (keyof A) | (keyof B)
  - keyof (A|B) = (keyof A) & (keyof B)
- A는 B를 상속 == A는 B에 할당가능 == A는 B의 서브타입 == A는 B의 부분집합

> **아이템 8 : 타입 공간과 값 공간의 심벌 구분하기**

- 타입스크립트 코드를 읽을 때 타입인지 값인지 구분하는 방법을 터득해야 한다.
- 모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다.
- class나 enum 같은 키워드는 타입과 값 두 가지로 사용될 수 있다.
- “foo”는 문자열 리터럴이거나 문자열 리터럴 타입일 수 있다. 차이점을 알고, 구별하는 방법을 터득해야 한다.
- typeof, this 그리고 많은 다른 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.

> **아이템 9 : 타입 단언보다는 타입 선언을 사용하기**

- 타입 단언(as Type)보다 타입 선언(: Type)을 사용해야 한다.
- 화살표 함수의 반환 타입을 명시하는 방법을 알아야 한다.
- 타입스크립트보다 타입 정보를 더 잘 알고 있는 상황에서는 타입 단언문을 사용하면 된다.

> **아이템 10 : 객체 래퍼 타입 피하기**

- 기본형 값에 메서드를 제공하기위해 객체 래퍼 타입이 어떻게 쓰이는지 이해해야 한다. 직접 사용하거나 인스턴스를 생성하는 것은 피해야 한다.
- 타입스크립트 객체 래퍼 타입은 지양하고, 대신 기본형 타입을 사용해야 한다.

> **아이템 11 : 잉여 속성 체크의 한계 인지하기**

- 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행된다.
  - 잉여속성체크 : **객체 리터럴을 직접 할당할 때** 추가 속성을 허용하지 않음
- 잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역할이 다르다. 할당의 개념을 정확히 알아야 잉여 속성 체크와 일반적인 구조적 할당 가능성 체크를 구분할 수 있다.
- 잉여 속성 체크에는 한계가 있다. 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다.

> **아이템 12 : 함수 표현식에 타입 적용하기**

- 매개변수나 반환 값에 타입을 명시하기 보다는 함수 표현식 전체에 타입 구문을 적용하는 것이 좋다.
- 만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아보도록 하는 것이 좋고, 라이브러리를 직접 만든다면 공통 콜백에 타입을 제공해야 한다.
- 다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 된다.

> **아이템 13 : 타입과 인터페이스의 차이점 알기**

- 타입과 인터페이스의 차이점과 비슷한 점을 이해해야 한다.
- 한 타입을 type과 interface 두 가지 문법을 사용해서 작성하는 방법을 터득해야 한다.
  - type은 유니온 연산이 가능하기 때문에 조건부로 타입을 명시하는 경우 type을 사용하는 것이 유리하다.
- 프로젝트에서 어떤 문법을 사용할 지 결정할 때 한 가지 일관된 스타일을 확립하고, 보강 기법이 필요한지 고려해야 한다.
  - 보통 보강기법(선언 머지)은 외부 모듈에 기능을 추가하기 위해 패키지를 확장할 때 유리함

> **아이템 14 : 타입 연산과 제네릭 사용으로 반복 줄이기(다시)**

- DRY 원칙을 타입에도 최대한 적용하자.
  - 타입에 이름붙이기
  - extends를 사용해서 인터페이스 필드의 반복 피하기
- 타입들 간의 매핑을 위해 타입스크립트가 제공한 도구(keyof, typeof, 인덱싱, 매핑된 타입)들을 공부하면 좋다.
- 제네릭 타입은 타입을 위한 함수와 같다. 타입을 반복하는 대신 제네릭 타입으르 사용해 타입들 간에 매핑을 하는것이 좋다. 제네릭 타입을 제한하려면 extends를 사용할 수 있다.
- 표준 라이브러리에 정의도딘 Pick, Partial, ReturnType 등의 제네릭 타입에 익숙해져야 한다.

> **아이템 15 : 동적 데이터에 인덱스 시그니처 사용하기**

- 런타임 때까지 객체의 속성을 알 수 없을 경우에만 인덱스 시그니처를 사용한다.
- 안전한 접근을 위해 인덱스 시그니처의 값 타입에 undefined를 추가하는 것을 고려해야 한다.
  ```tsx
  type MySafeMap = {
    [key: string]: string;
  };

  // m['hello']는 실제로 undefined지만, ts컴파일러는 string이라고 생각해 타입 에러를 내지않음
  // -> 런타임에서 에러가 발생함
  const m: MySafeMap = {};
  m['hello'].toUpperCase();

  // 해결법 : undefined 추가
  type MySafeMap = {
    [key: string]: string | undefined;
  };
  ```
- 가능하다면 인터페이스, Record, 매핑된 타입 같은 인덱스 시그니처보다 정확한 타입을 사용하는것이 좋다.

> **아이템 16 : number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기(다시)**

- 배열은 객체이므로 키가 숫자가 아니라 문자열이다. 인덱스 시그니처로 사용된 number타입은 버그를 잡기 위한 순수타입스크립트 코드다.
- 인덱스 시그니처에 number를 사용하기보다 Array나 튜플, 또는 ArrayLike 타입을 사용하는 것이 좋다.
  - Array나 튜플이 타입 안전도, 자동완성, 메서드 지원, 추론 측면에서 낫다.

> **아이템 17 : 변경 관련된 오류 방지를 위해 readonly 사용하기(다시)**

- 만약 함수가 매개변수를 수정하지 않는다면 readonly로 선언하는 것이 좋다. readonly 매개변수는 인터페이스를 명확하게 하며, 매개변수가 변경되는 것을 방지한다.
- readonly를 사용하면 변경하면서 발생하는 오류를 방지할 수 있고, 변경이 발생하는 코드도 쉽게 찾을 수 있다.
- const 와 readonly의 차이를 이해해야 한다.
- readonly는 얕게 동작한다는 것을 명심해야 한다.

> **아이템 18 : 매핑된 타입을 사용하여 값을 동기화하기(다시)**

- 매핑된 타입을 사용해서 관련된 값과 타입을 동기화하도록 한다.
- 인터페이스에 새로운 속성을 추가할 때, 선택을 강제하도록 매핑된 타입을 고려해야 한다.

### 3장 타입 추론

> **아이템 19 : 추론 가능한 타입을 사용해 장황한 코드 방지하기**

- 타입스크림트가 타입을 추론할 수 있다면 타입 구문을 작성하지 않는 것이 좋다.
  - 즉 알잘딱깔센으로 타입을 작성해라
- 이상적인 경우 함수/메서드의 시그니처에는 타입 구문이 있지만, 함수 내의 지역변수에는 타입 구문이 없다.
- 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야 한다. 이는 내부 구현의 오류가 사용자 코드 위치에 나타나는 것을 방지해준다.
  - 객체리터럴과 함수 반환의 경우 타입 명시를 하지 않으면 코드가 정의된 곳이 아닌 사용되는 곳에서 오류가 나서 오류 추적이 어려워짐.

> **아이템 20 : 다른 타입에는 다른 변수 사용하기**

- 변수의 값은 바뀔 수 있지만 타입은 일반적으로 바뀌지 않는다.
- 혼란을 막기 위해 타입이 다른 값을 다룰 때에는 변수를 재사용하지 않도록 한다.
  - 즉 타입이 다른 값은 변수를 재사용 하지 말고 분리해라

> **아이템 21 : 타입 넓히기**

- 타입스크립트가 넓히기를 통해 상수의 타입을 추론하는 법을 이해해야 한다.
  - 타입스크립트가 작성된 코드를 정적 분석하는 시점에 변수는 가능한 값들의 집합을 가지게 됨. 타입체커는 이 때 타입을 가능한 값들의 집합을 유추해야 하는데 이 과정을 타입 넓히기라고 함
- 동작에 영향을 줄 수 있는 방법인 const, 타입 구문, 문맥, as const에 익숙해져야 한다.

> **아이템 22 : 타입 좁히기**

- 분기문 외에도 여러 종류의 제어 흐름을 살펴보며 타입스크립트가 타입을 좁히는 과정을 이해해야 한다.
  - 조건문, instanceof, in, isArray, typeof 등
- 태그된/구별된 유니온과 사용자 정의 타입 가드를 사용해 타입좁히기 과정을 원할하게 만들 수 있다.

> **아이템 23 : 한꺼번에 객체 생성하기**

- 속성을 제각각 추가하지 말고 한꺼번에 객체로 만들어야 한다. 안전한 타입으로 속성을 추가하려면 객체 전개를 사용하면 된다.
- 객체에 조건부로 속성을 추가하는 방법을 익혀야 한다.

> **아이템 24 : 일관성 있는 별칭 사용하기**

- 별칭은 타입스크립트가 타입을 좁히는 것을 방해한다. 따라서 변수에 별칭을 사용할 때는 일관되게 사용해야 한다.
- 비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋다.
- 함수 호출이 객체 속성의 타입 정제를 무효화할 수 있다는 점을 주의해야 한다. 속성보다 지역변수를 사용하면 타입 정제를 믿을 수 있다.

> **아이템 25 : 비동기 코드에는 콜백 대신 async 함수 사용하기**

- 콜백보다는 프로미스를 사용하는 게 코드 작성과 타입 추론면에서 유리하다.
- 가능하면 프로미스를 생성하기보다는 async와 await를 사용하는 것이 좋다. 간결하고 직관적인 코드를 작성할 수 있고, 모든 종류의 오류를 제거할 수 있다.
- 어떤 함수가 프로미스를 반환한다면 async로 선언하는 것이 좋다.

> **아이템 26 : 타입 추론에 문맥이 어떻게 사용되는지 이해하기**

- 타입 추론에서 문맥이 어떻게 쓰이는지 주의해서 살펴봐야 한다.
- 변수를 뽑아서 별도로 선언했을 때 오류가 발생한다면 타입 선언을 추가해야 한다.
  - 타입은 “할당”시점에 추론되므로 문맥상 할당 시점의 타입과 값을 사용하는 위치에서의 타입이 일치 하는지 확인해봐야 함
- 변수가 정말 상수라면 상수 단언(as const)를 사용해야 한다. 그러나 상수 단언을 사용하면 정의한 곳이 아니라 사용한 곳에서 오류가 발생하므로 주의해야 한다.

> **아이템 27 : 함수형 기법과 라이브러리로 타입 흐름 유지하기**

- 타입 흐름을 개선하고, 가독성을 높이고, 명시적인 타입 구문의 필요성을 줄이기 위해 직접 구현하기보다는 내장된 함수형 기법과 로대시 같은 유틸리티 라이브러리를 사용하는 것이 좋다.
